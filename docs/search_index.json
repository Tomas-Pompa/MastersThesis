[["index.html", "Diplomová práce Kapitola 1 Klasifikace", " Diplomová práce Tomáš Pompa 2023-11-01 Kapitola 1 Klasifikace "],["metoda-podpůrných-vektorů-pro-funkcionální-data.html", "Kapitola 2 Metoda podpůrných vektorů pro funkcionální data", " Kapitola 2 Metoda podpůrných vektorů pro funkcionální data Cílem bude aplikovat poznatky o metodě podpůrných vektorů (SVM) pro mnohorozměrná data na data funkcionálního typu, tedy nekonečně-rozměrné objekty. K tomu využijeme jednak převod (redukci) objektů z nekonečné dimenze na objekty konečné dimenze a následným využitím známých postupů a také modifikaci SVM přímo pro funkcionální data, k čemuž využijeme poznatky o Hilbertových prostorech a skalárním součinu. Dalším cílem bude porovnání jednotlivých metod pro klasifikaci funkcionálních dat na reálných a simulovaných datech. Bylo by dobré vymyslet nějakou zajímavou simulační studii, která bude demonstrovat různá chování uvažovaných metod. Mezi uvažované klasifikační metody patří: \\(K\\) nejbližších sousedů (KNN), logistická regrese (jak obyčejná (LR) tak její funkcionální modifikace (LR_fda)), lineární (LDA) a kvadratická (QDA) diskriminační analýza, rozhodovací stromy (DT) a náhodné lesy (RF). Postupně jednotlivé metody projdeme, nejprve na simulovaných datech, a následně budeme konstruovat metodu podpůrných vektorů pro funkcionální data (SVM_fda). Základním balíčkem v R pro práci s funkcionálními objekty je fda. Dalšími užitečnými balíčky budou MASS, e1071, fda.usc, refund a další. "],["simulace-funkcionálních-dat.html", "Kapitola 3 Simulace funkcionálních dat", " Kapitola 3 Simulace funkcionálních dat Nejprve si simulujeme funkce, které budeme následně chtít klasifikovat. Budeme uvažovat pro jednoduchost dvě klasifikační třídy. Pro simulaci nejprve: zvolíme vhodné funkce, generujeme body ze zvoleného intervalu, které obsahují , například gaussovský, šum, takto získané diskrétní body vyhladíme do podoby funkcionálního objektu pomocí nějakého vhodného bázového systému. Tímto postupem získáme funkcionální objekty společně s hodnotou kategoriální proměnné \\(Y\\), která rozlišuje příslušnost do klasifikační třídy. Code # nacteme potrebne balicky library(fda) library(ggplot2) library(dplyr) library(tidyr) library(ddalpha) # set.seed(42) Uvažujme tedy dvě klasifikační třídy, \\(Y \\in \\{0, 1\\}\\), pro každou ze tříd stejný počet n generovaných funkcí. Definujme si nejprve dvě funkce, každá bude pro jednu třídu. Funkce budeme uvažovat na intervalu \\(I = [0, 1]\\). Pro třídu \\(Y = 0\\) a \\(Y = 1\\) uvažujme funkce \\[ f_0(x) = 2 \\cdot \\sin\\left(\\frac{\\pi x}{2}\\right) + x^2 + \\frac{1}{2}, \\] \\[ f_1(x) = 3 \\cdot \\sin\\left(\\frac{\\pi x}{2}\\right) + \\frac{1}{2} x. \\] Jejich grafy jsou na obrázcích níže. Code # generujici funkce pro Y = 0 a Y = 1 funkce_0 &lt;- function(x) {return(2 * sin(x*pi/2) + x^2 + 0.5)} # pridat nahodny posun v zacatku nebo periode funkce_1 &lt;- function(x) {return(3 * sin(x*pi/2) + 0.5 * x)} Code x &lt;- seq(0, 1, length = 501) y0 &lt;- funkce_0(x) y1 &lt;- funkce_1(x) df &lt;- data.frame(x = rep(x, 2), y = c(y0, y1), Y = rep(c(&#39;Y = 0&#39;, &#39;Y = 1&#39;), each = length(x))) df |&gt; ggplot(aes(x = x, y = y, colour = Y)) + geom_line(linewidth = 1) + theme_bw() + labs(colour = &#39;Group&#39;) Figure 3.1: Znázornění dvou funkcí na intervalu \\([0, 1]\\), ze kterých generujeme pozorování ze tříd 0 a 1. Nyní si vytvoříme funkci pro generování náhodných funkcí s přidaným šumem (resp. bodů na předem dané síti) ze zvolené generující funkce. Argument t označuje vektor hodnot, ve kterých chceme dané funkce vyhodnotit, fun značí generující funkci, n počet funkcí a sigma směrodatnou odchylku \\(\\sigma\\) normálního rozdělení \\(\\text{N}(\\mu, \\sigma^2)\\), ze kterého náhodně generujeme gaussovský bílý šum s \\(\\mu = 0\\). Abychom ukázali výhodu použití metod, které pracují s funkcionálními daty, přidáme při generování ke každému simulovanému pozorování navíc i náhodný člen, který bude mít význam vertikálního posunu celé funkce. Tento posun budeme generovat s exponenciálního rozdělění s parametrem \\(\\lambda_{\\text{exp}}\\). Code generate_values &lt;- function(t, fun, n, sigma, lambda_exp = Inf) { # Arguments: # t ... vector of values, where the function will be evaluated # fun ... generating function of t # n ... the number of generated functions / objects # sigma ... standard deviation of normal distribution to add noise to data # lambda_exp ... parameter of exponential distribution # Value: # X ... matrix of dimension length(t) times n with generated values of one # function in a column X &lt;- matrix(rep(t, times = n), ncol = n, nrow = length(t), byrow = FALSE) noise &lt;- matrix(rnorm(n * length(t), mean = 0, sd = sigma), ncol = n, nrow = length(t), byrow = FALSE) shift &lt;- matrix(rep(rexp(n, rate = lambda_exp), each = length(t)), ncol = n, nrow = length(t)) return(fun(X) + noise + shift) } Nyní můžeme generovat funkce. V každé ze dvou tříd budeme uvažovat 100 pozorování, tedy n = 100. Code # pocet vygenerovanych pozorovani pro kazdou tridu n &lt;- 100 # vektor casu ekvidistantni na intervalu [0, 1] t &lt;- seq(0, 1, length = 51) # pro Y = 0 X0 &lt;- generate_values(t, funkce_0, n, 1, 0.6) # pro Y = 1 X1 &lt;- generate_values(t, funkce_1, n, 1, 0.6) Vykreslíme vygenerované (ještě nevyhlazené) funkce barevně v závislosti na třídě (pouze prvních 10 pozorování z každé třídy pro přehlednost). Code n_curves_plot &lt;- 10 # pocet krivek, ktere chceme vykreslit z kazde skupiny DF0 &lt;- cbind(t, X0[, 1:n_curves_plot]) |&gt; as.data.frame() |&gt; reshape(varying = 2:(n_curves_plot + 1), direction = &#39;long&#39;, sep = &#39;&#39;) |&gt; subset(select = -id) |&gt; mutate( time = time - 1, group = 0 ) DF1 &lt;- cbind(t, X1[, 1:n_curves_plot]) |&gt; as.data.frame() |&gt; reshape(varying = 2:(n_curves_plot + 1), direction = &#39;long&#39;, sep = &#39;&#39;) |&gt; subset(select = -id) |&gt; mutate( time = time - 1, group = 1 ) DF &lt;- rbind(DF0, DF1) |&gt; mutate(group = factor(group)) DF |&gt; ggplot(aes(x = t, y = V, group = interaction(time, group), colour = group)) + geom_line(linewidth = 0.5) + theme_bw() + labs(x = &#39;Time&#39;, y = &#39;Function&#39;, colour = &#39;Group&#39;) + scale_colour_discrete(labels=c(&#39;Y = 0&#39;, &#39;Y = 1&#39;)) Figure 3.2: Prvních 10 vygenerovaných pozorování z každé ze dvou klasifikačních tříd. Pozorovaná data nejsou vyhlazená. pokud chci napsat matematiku \\[\\begin{equation} Y = 2 \\end{equation}\\] "],["vyhlazení-pozorovaných-křivek.html", "Kapitola 4 Vyhlazení pozorovaných křivek", " Kapitola 4 Vyhlazení pozorovaných křivek Nyní převedeme pozorované diskrétní hodnoty (vektory hodnot) na funkcionální objekty, se kterými budeme následně pracovat. Jelikož se nejedná o periodické křivky na intervalu \\(I = [0, 1]\\), využijeme k vyhlazení B-sline bázi. Za uzly bereme celý vektor t, standardně uvažujeme kubické spliny, proto volíme (implicitní volba v R) norder = 4. Budeme penalizovat druhou derivaci funkcí. "],["klasifikace-křivek.html", "Kapitola 5 Klasifikace křivek", " Kapitola 5 Klasifikace křivek Nejprve načteme potřebné knihovny pro klasifikaci. Code library(caTools) # pro rozdeleni na testovaci a trenovaci library(caret) # pro k-fold CV library(fda.usc) # pro KNN, fLR library(MASS) # pro LDA library(fdapace) library(pracma) library(refund) # pro LR na skorech library(nnet) # pro LR na skorech library(caret) library(rpart) # stromy library(rattle) # grafika library(e1071) library(randomForest) # nahodny les Abychom mohli jednotlivé klasifikátory porovnat, rozdělíme množinu vygenerovaných pozorování na dvě části v poměru 70:30, a to na trénovací a testovací (validační) část. Trénovací část použijeme při konstrukci klasifikátoru a testovací na výpočet chyby klasifikace a případně dalších charakteristik našeho modelu. Výsledné klasifikátory podle těchto spočtených charakteristik můžeme následně porovnat mezi sebou z pohledu jejich úspěnosti klasifikace. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
